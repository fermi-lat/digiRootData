<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft FrontPage 4.0">
<TITLE>digiRootData documentation</TITLE>
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Office\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#FFFFCC">

<B><FONT SIZE=5><P ALIGN="CENTER">digiRootData</P>

</B></FONT>
<blockquote>
  <blockquote>
    <P align="center"><A HREF="#Intro">Introduction</A>&nbsp;&nbsp;&nbsp;<a href="#Class Overview">Class
    Overview</a>&nbsp;&nbsp;&nbsp; <a href="#Event">DigiEvent</a>&nbsp;&nbsp;&nbsp;
    <a href="#ACD/XGT">ACD</a>&nbsp;&nbsp;&nbsp;
    <a href="#CAL">CAL</a>&nbsp;&nbsp;&nbsp; <a href="#TKR">TKR</a>&nbsp;&nbsp;&nbsp;<a href="#L1T">L1T</a>&nbsp;
    <A HREF="#Bugs">Known
    Issues</A></P>
  </blockquote>
</blockquote>

<B><P ALIGN="JUSTIFY"><A NAME="Intro">Introduction:</P>
</A>
</B><P ALIGN="JUSTIFY">This package contains the definition of our digitization
ROOT classes.&nbsp; These classes were originally defined for the GLAST 1999
beamtest (TBEvent) and have undergone a number of mutations since then.&nbsp;
This is the current form of our digi data.</P>
<P ALIGN="JUSTIFY"><b><a name="Class Overview">Class Overview</a></b></P>
<P ALIGN="JUSTIFY">The top-level class is called <i>DigiEvent </i>this class
contains the data for one event.&nbsp; The detector data for each subsystems is stored in a
separate data collection..&nbsp; The ACD data is stored in collection of <i>AcdDigi</i>
objects.&nbsp; The CAL data is stored as an collection of <i>CalDigi</i>
objects.&nbsp; The TKR data is stored as a collection of <i>TkrDigi</i> objects -
where each <i>TkrDigi</i> contains a list of hit strips for a particular layer
in the TKR.&nbsp; The
Level One Trigger data is stored in a class called <i>L1T</i>.</P>
<h3>Digi Tree</h3>
<p>The Digi tree has one main branch, <a href="#DigiEvent">DigiEvent</a>.&nbsp; All of the Digitization data is
contained within this branch.</p>
<P ALIGN="JUSTIFY"><img border="0" src="images/digiTree.jpg" width="621" height="436"></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
        <h3><a name="Method">Method </a>Definitions</h3>
<p><b><a name="DigiEvent">DigiEvent</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="100%" colspan="3">
      <p align="center">Summary Data</td>
  </tr>
  <tr>
    <td width="33%">getEventId( )</td>
    <td width="33%">Returns the Event Id</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getRunId( )</td>
    <td width="33%">Returns the Run Id</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getL1T( )</td>
    <td width="33%">Returns the Level One Trigger</td>
    <td width="34%">const <a href="#L1T">L1T</a>&amp;</td>
  </tr>
  <tr>
    <td width="33%">getTimeStamp( )</td>
    <td width="33%">Time in seconds.&nbsp; This is the time that is reported
      when doing simulations.&nbsp;</td>
    <td width="34%">Double_t</td>
  </tr>
  <tr>
    <td width="33%">getEbfTimeSec( )</td>
    <td width="33%">Returns the number of seconds, used in conjunction with
      getEbfTimeNanoSec for a measure of absolute time.&nbsp; This data is only
      available when processing LDF data from real tests.</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getEbfTimeNanoSec( )</td>
    <td width="33%">Returns the number of nano-seconds, used in conjunction with
      getEbfTimeSec for a measure of absolute time.&nbsp; This data is only
      available when processing LDF data from real tests.</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getEbfUpperPpcTimeBase( )</td>
    <td width="33%">Returns the UpperPpcTimeBase word as stored in the LDF from
      real tests.&nbsp; Used in conjunction with getEbfLowerPpcTimeBase, these
      words can be used to determine the spacing of real test events.&nbsp; Also
      see getEbfPpcTimeSeconds( )</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getEbfLowerPpcTimeBase( )</td>
    <td width="33%">Returns the LowerPpcTimeBase word stored in the LDF from
      real tests, used in conjunction with getEbfUpperPpcTimeBase, these words
      can be used to determine the spacing of real test events.&nbsp; Also see
      getEbfPpcTimeSeconds( )</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getEbfPpcTimeSeconds( )</td>
    <td width="33%">Uses the data words stored in the UpperPpcTimeBase and
      LowerPpcTimeBase to calculate seconds since power on.&nbsp; This time is
      used to determine the spacing of events - NOT as an absolute time.&nbsp;
      This is only available when processing LDF data from real tests.</td>
    <td width="34%">Double_t</td>
  </tr>
  <tr>
    <td width="33%">getEventSummaryData( )</td>
    <td width="33%">Returns the full EventSummaryData object.&nbsp; This is only
      available when processing LDF data from real tests.</td>
    <td width="34%">const <a href="#EventSummaryData">EventSummaryData</a>&amp;</td>
  </tr>
  <tr>
    <td width="33%">getFromMc( )</td>
    <td width="33%">Returns a flag denoting whether or not this data originated
      from Monte Carlo simulation (kTRUE) or not (kFALSE)</td>
    <td width="34%">Bool_t</td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bordercolordark="#008000">
      <p align="center">ACD</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#008000">getAcdDigiCol( )</td>
    <td width="33%" bordercolordark="#008000">Returns the full collection of AcdDigi objects</td>
    <td width="34%" bordercolordark="#008000">const TClonesArray*</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#008000">getAcdDigi(UShort layer, UShort face, UShort row, UShort col
      )</td>
    <td width="33%" bordercolordark="#008000">Returns a specific AcdDigi object identified by layer, face,
      row, column</td>
    <td width="34%" bordercolordark="#008000">const <a href="#AcdDigi">AcdDigi</a>*</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#008000">getAcdDigi(const AcdId&amp; )</td>
    <td width="33%" bordercolordark="#008000">Returns a specific AcdDigi object identified by its AcdId</td>
    <td width="34%" bordercolordark="#008000">const <a href="#AcdDigi">AcdDigi</a>*</td>
  </tr>
  <tr>
    <td width="100%" bordercolordark="#800000" colspan="3">
      <p align="center">CAL</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#800000">getCalDigiCol( )</td>
    <td width="33%" bordercolordark="#800000">Returns the complete CalDigi collection</td>
    <td width="34%" bordercolordark="#800000">const TClonesArray*</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#800000">getCalDigi(UInt_t i)</td>
    <td width="33%" bordercolordark="#800000">Returns a specific CalDigi object identified by its index in
      the TObjArray</td>
    <td width="34%" bordercolordark="#800000">const <a href="#CalDigi">CalDigi</a>*</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#800000">getCalDiagnosticCol( )</td>
    <td width="33%" bordercolordark="#800000">Returns the full collection of CAL
      Diagnostic data - only available when processing LDF files storing real
      test data.</td>
    <td width="34%" bordercolordark="#800000">const TClonesArray*</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#800000">getCalDiagnostic(UInt_t i )</td>
    <td width="33%" bordercolordark="#800000">Returns the ith CalDiagnostic
      object.&nbsp; Only available when processing LDF files storing real test
      data.</td>
    <td width="34%" bordercolordark="#800000">const <a href="#CalDiagnostic">CalDiagnosticData</a>*</td>
  </tr>
  <tr>
    <td width="100%" colspan="3" bordercolordark="#0000FF">
      <p align="center">TKR</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#0000FF">getTkrDigiCol( )</td>
    <td width="33%" bordercolordark="#0000FF">Returns the complete TkrDigi collection</td>
    <td width="34%" bordercolordark="#0000FF">const TObjArray*</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#0000FF">getTkrDigi( )</td>
    <td width="33%" bordercolordark="#0000FF">Returns a specific TkrDigi object identified by its index in
      the TObjArray</td>
    <td width="34%" bordercolordark="#0000FF">const <a href="#TkrDigi">TkrDigi</a>*</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#0000FF">getTkrDiagnosticCol( )</td>
    <td width="33%" bordercolordark="#0000FF">Returns the full collection of
      TkrDiagnostic objects.&nbsp; This collection is only available when
      processing LDF file from real test data.</td>
    <td width="34%" bordercolordark="#0000FF">const TClonesArray*</td>
  </tr>
  <tr>
    <td width="33%" bordercolordark="#0000FF">getTkrDiagnostic(UInt_t i)</td>
    <td width="33%" bordercolordark="#0000FF">Returns the ith TkrDiagnostic
      object in the collection.&nbsp; This collection is populated only when
      processing LDF files storing real test data</td>
    <td width="34%" bordercolordark="#0000FF">const <a href="#TkrDiagnosticData">TkrDiagnosticData</a>*</td>
  </tr>
</table>
<p>&nbsp;</p>
<p><b><a name="EventSummaryData">EventSummaryData<br>
</a></b>This class is just an interface to the LDF Online's EventSummary
class.&nbsp; All of the methods use the Online's methods to unpack the summary
data.&nbsp; For a full description of the EventSummary data please see:</p>
<p><a href="http://www-glast.slac.stanford.edu/IntegrationTest/ONLINE/docs/LATcom.pdf">http://www-glast.slac.stanford.edu/IntegrationTest/ONLINE/docs/LATcom.pdf</a></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">summary( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">calStrobe( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">tag( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">TACK( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">readout4( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">zeroSuppress( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">marker( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">error( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">diagnostic( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">eventNumber( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">trgParityError( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
</table>
<p><b><a name="L1T">L1T</a></b></p>
<table border="1" width="100%" height="100">
  <tr>
    <td width="33%" height="19">getTriggerWord( )</td>
    <td width="33%" height="19">Returns the full trigger word</td>
    <td width="34%" height="19">UInt_t</td>
  </tr>
  <tr>
    <td width="33%" height="19">getAcdLow( )</td>
    <td width="33%" height="19">Returns kTRUE if ACD LOW</td>
    <td width="34%" height="19">Bool_t</td>
  </tr>
  <tr>
    <td width="33%" height="19">getAcdHigh( )</td>
    <td width="33%" height="19">Returns kTRUE is ACD HIGH</td>
    <td width="34%" height="19">Bool_t</td>
  </tr>
  <tr>
    <td width="33%" height="19">getTkr3InARow( )</td>
    <td width="33%" height="19">Returns kTRUE if 3-in-a-row in the TKR has
      occurred</td>
    <td width="34%" height="19">Bool_t</td>
  </tr>
  <tr>
    <td width="33%" height="19">getCalLow( )</td>
    <td width="33%" height="19">Returns kTRUE if CAL LOW</td>
    <td width="34%" height="19">Bool_t</td>
  </tr>
  <tr>
    <td width="33%" height="19">getCalHigh( )</td>
    <td width="33%" height="19">Returns kTRUE if CAL HIGH</td>
    <td width="34%" height="19">Bool_t</td>
  </tr>
</table>
<p>&nbsp;</p>
<p><b><a name="AcdDigi">AcdDigi</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">getId( )</td>
    <td width="33%">Returns the AcdId associated with this digi</td>
    <td width="34%">const <a href="#AcdId">AcdId</a>&amp;</td>
  </tr>
  <tr>
    <td width="33%">getVolId( )</td>
    <td width="33%">Returns the VolumeIdentifier associated with this digi.</td>
    <td width="34%">const <a href="http://www-glast.slac.stanford.edu/software/gleam/userGuide/mcRoot.htm">VolumeIdentifie</a>r&amp;</td>
  </tr>
  <tr>
    <td width="33%">getPulseHeight(AcdDigi::PmtId )</td>
    <td width="33%">Returns the PHA (Pulse Height Analysis) for this ACD
      detector</td>
    <td width="34%">UShort_t</td>
  </tr>
  <tr>
    <td width="33%">getVeto(AcdDigi::PmtId)</td>
    <td width="33%">Returns kTRUE if the veto discriminator is set, returns
      kFALSE otherwise</td>
    <td width="34%">Bool_t</td>
  </tr>
  <tr>
    <td width="33%">get:LowDiscrim(AcdDigi::PmtId )</td>
    <td width="33%">Returns kTRUE if the low discriminator is set, returns
      kFALSE otherwise</td>
    <td width="34%">Bool_t</td>
  </tr>
  <tr>
    <td width="33%">getHighDiscrim(AcdDigi::PmtId)</td>
    <td width="33%">Returns kTRUE if the high (CNO) discriminator is set,
      returns kFALSE otherwise</td>
    <td width="34%">Bool_t</td>
  </tr>
</table>
<p><b><a name="AcdId">AcdId</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">getId(Short_t base = 10 )</td>
    <td width="33%">Returns a numerical value for the AcdId, by default in base
      10.</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">isTop( )</td>
    <td width="33%">Returns kTRUE if this Acd detector is on the top (Face 0) of
      the instrument, returns kFALSE otherwise</td>
    <td width="34%">Bool_t</td>
  </tr>
  <tr>
    <td width="33%">isSide( )</td>
    <td width="33%">Returns kTRUE if this Acd detector is on a side (Face != 0),
      returns kFALSE otherwise</td>
    <td width="34%">Bool_t</td>
  </tr>
  <tr>
    <td width="33%">getLayer( )</td>
    <td width="33%">Returns the layer number of this AcdId</td>
    <td width="34%">UShort_t</td>
  </tr>
  <tr>
    <td width="33%">getFace( )</td>
    <td width="33%">Returns the face number [0-4]</td>
    <td width="34%">UShort_t</td>
  </tr>
  <tr>
    <td width="33%">getRow( )</td>
    <td width="33%">Returns the row number</td>
    <td width="34%">UShort_t</td>
  </tr>
  <tr>
    <td width="33%">getColumn( )</td>
    <td width="33%">Returns the column number</td>
    <td width="34%">UShort_t</td>
  </tr>
</table>
<p><b><a name="CalDigi">CalDigi</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">getMode( )</td>
    <td width="33%">Returns the readout mode</td>
    <td width="34%">CalXtalId::CalTrigMode</td>
  </tr>
  <tr>
    <td width="33%">getPackedId( )</td>
    <td width="33%">Returns the crystal id associated with this CalDigi</td>
    <td width="34%">const <a href="#CalXtalId">CalXtalId</a></td>
  </tr>
  <tr>
    <td width="33%">getReadoutCol( )</td>
    <td width="33%">Returns the full collection of CalXtalReadout objects</td>
    <td width="34%">const TClonesArray*</td>
  </tr>
  <tr>
    <td width="33%">getRange(short readoutIndex, CalXtalId::XtalFace face)</td>
    <td width="33%">Retrieve energy range for selected face and readout</td>
    <td width="34%">Char_t</td>
  </tr>
  <tr>
    <td width="33%">getAdc(Short_t readoutIndex, CalXtalId::XtalFace face)</td>
    <td width="33%">Retrieve pulse height for selected face and readout</td>
    <td width="34%">Short_t</td>
  </tr>
  <tr>
    <td width="33%">getXtalReadout(Short_t readoutIndex)</td>
    <td width="33%">Retrieve ranges and pulse heights from both ends of selected readout</td>
    <td width="34%">const <a href="#CalXtalReadout">CalXtalReadout</a>*</td>
  </tr>
  <tr>
    <td width="33%">getAdcSelectedRange(Char_t range, CalXtalId::XtalFace face)</td>
    <td width="33%">Retrieve pulse height from selected range</td>
    <td width="34%">Short_t</td>
  </tr>
</table>
<p><b><a name="CalXtalId">CalXtalId</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">getPackedId( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getUnpackedId(Short_t&amp; tower, Short_t&amp; layer, Short_t&amp; column)</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">void</td>
  </tr>
  <tr>
    <td width="33%">getTower( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">Short_t</td>
  </tr>
  <tr>
    <td width="33%">getLayer( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">Short_t</td>
  </tr>
  <tr>
    <td width="33%">getColumn( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">Short_t</td>
  </tr>
</table>
<p><b><a name="CalXtalReadout">CalXtalReadout</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">getAdc(CalXtalId::XtalFace face)</td>
    <td width="33%">retrieve pulse height from specified face</td>
    <td width="34%">UShort_t</td>
  </tr>
  <tr>
    <td width="33%">getRange(CalXtalId::XtalFace face)</td>
    <td width="33%">retrieve energy range from specified face</td>
    <td width="34%">Char_t</td>
  </tr>
</table>
<p><b><a name="CalDiagnostic">CalDiagnosticData<br>
</a></b>This class is just an interface to the Online's LDF CALdiagnostic class.</p>
<p><a href="http://www-glast.slac.stanford.edu/IntegrationTest/ONLINE/docs/TEM.pdf">http://www-glast.slac.stanford.edu/IntegrationTest/ONLINE/docs/TEM.pdf</a></p>
<table border="1" width="100%" height="94">
  <tr>
    <td width="33%" height="19">getDataWord( )</td>
    <td width="33%" height="19">Returns the full data word for this
      CALdiagnostic</td>
    <td width="34%" height="19">UInt_t</td>
  </tr>
  <tr>
    <td width="33%" height="13">high(UInt_t sign )</td>
    <td width="33%" height="13">Returns high energy trigger request value for
      the specified layer end:&nbsp; 0-Positiive, 1-Negative</td>
    <td width="34%" height="13">UInt_t</td>
  </tr>
  <tr>
    <td width="33%" height="19">low( UInt_t sign)</td>
    <td width="33%" height="19">Returns low energy trigger request value for
      specified layer end:&nbsp; 0-Positive, 1-Negative</td>
    <td width="34%" height="19">UInt_t</td>
  </tr>
  <tr>
    <td width="33%" height="19">logAccepts(UInt_t sign )</td>
    <td width="33%" height="19">Returns status of logaccepts lines for the
      specified layer end:&nbsp; 0-Positive, 1-Negative</td>
    <td width="34%" height="19">UInt_t</td>
  </tr>
</table>
<p><b><a name="GlastAxis">GlastAxis</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">enum axis {X=0, Y=1, XY=2, NONE=3}</td>
    <td width="33%">An enumeration that identifies orientation.</td>
    <td width="34%">&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<p><b><a name="TkrDigi">TkrDigi</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">getTower( )</td>
    <td width="33%">Returns the tower identifier associated with this TkrDigi</td>
    <td width="34%"><a href="#TowerId">TowerId</a></td>
  </tr>
  <tr>
    <td width="33%">getBilayer( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">UShort_t</td>
  </tr>
  <tr>
    <td width="33%">getView( )</td>
    <td width="33%">Returns the view which denotes the orientation of the strips</td>
    <td width="34%"><a href="#GlastAxis">GlastAxis::axis</a></td>
  </tr>
  <tr>
    <td width="33%">getLastController0Strip()</td>
    <td width="33%">Retrieve the last strip associated with controller zero</td>
    <td width="34%">Int_t</td>
  </tr>
  <tr>
    <td width="33%">getToT(UInt_t i)</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">Int_t</td>
  </tr>
  <tr>
    <td width="33%">getToTForStrip(UInt_t strip)</td>
    <td width="33%">Returns Time Over Threshold for a given strip</td>
    <td width="34%">Int_t</td>
  </tr>
  <tr>
    <td width="33%">getNumHits( )</td>
    <td width="33%">Returns the number of hits associated with this TkrDigi</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getStrip(UInt_t i)</td>
    <td width="33%">Returns the ith strip number</td>
    <td width="34%">Int_t</td>
  </tr>
  <tr>
    <td width="33%">getHit(UInt_t i)</td>
    <td width="33%">Returns a specific hit identifier by its index in the
      collection of hits</td>
    <td width="34%">Int_t</td>
  </tr>
  <tr>
    <td width="33%">getHitCol( )</td>
    <td width="33%">Returns the full collection of hit strips</td>
    <td width="34%">std::vector&lt;UInt_t&gt;</td>
  </tr>
</table>
<p><b><a name="TkrDiagnosticData">TkrDiagnosticData</a></b></p>
<p>This class is just an interface to the Online's LDF TKRdiagnostic
class.&nbsp; We use the TKRdiagnostic class to unpack the data.</p>
<table border="1" width="100%">
  <tr>
    <td width="33%">dataWord( )</td>
    <td width="33%">returns full data word associated with this TKRdiagnostic</td>
    <td width="34%">UInt_t</td>
  </tr>
  <tr>
    <td width="33%">getGTRC( int gtrc )</td>
    <td width="33%">Returns the state of the trigger request line for the given
      GTRC</td>
    <td width="34%">UInt_t</td>
  </tr>
</table>
<p><b><a name="TowerId">TowerId</a></b></p>
<table border="1" width="100%">
  <tr>
    <td width="33%">id( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">Int_t</td>
  </tr>
  <tr>
    <td width="33%">ix( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">Int_t</td>
  </tr>
  <tr>
    <td width="33%">iy( )</td>
    <td width="33%">&nbsp;</td>
    <td width="34%">Int_t</td>
  </tr>
  <tr>
    <td width="33%">neighbor (const TowerId&amp; n)</td>
    <td width="33%">Reports whether or not a tower identifier by TowerId n is a
      neighbor (kTRUE) or not (kFALSE)</td>
    <td width="34%">Bool_t</td>
  </tr>
</table>
<p>&nbsp;</p>
</BODY>
</HTML>
